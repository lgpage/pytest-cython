""" discover and run doctests in Cython extension modules."""

import os
import pathlib
import re
import sys
import sysconfig

import pytest

from typing import Iterable

from _pytest.doctest import DoctestModule, DoctestItem
from _pytest.pathlib import ImportMode


CYTHON_SUFFIXES = ['.py', '.pyx']
EXT_SUFFIX = sysconfig.get_config_var("EXT_SUFFIX")


def check_python_versions():
    (major, minor, patch, *_) = sys.version_info
    if (major == 3):
        if (minor == 8 and patch < 7) or (minor == 9 and patch < 2):
            raise RuntimeError(' '.join([
                "Please update your Python patch version.",
                "Your current Python version has a known bug w.r.t. EXT_SUFFIX that prevents this plugin from working.",
            ]))


def pytest_addoption(parser: pytest.Parser):
    group = parser.getgroup("cython")

    group.addoption(
        "--doctest-cython",
        action="store_true",
        default=False,
        help="run doctests in all .so and .pyd modules",
        dest="doctest_cython",
    )


def pytest_collect_file(file_path: pathlib.Path, path, parent: pytest.Collector) -> pytest.Module:
    config = parent.config
    if file_path.suffix not in CYTHON_SUFFIXES or not config.getoption('--doctest-cython'):
        return

    bin_path = file_path.with_suffix(EXT_SUFFIX)
    if not bin_path.exists():
        return

    # only run test if matching .so and .pyx files exist
    check_python_versions()
    return _PatchedDoctestModule.from_parent(parent, path=file_path)


class _PatchedDoctestModule(DoctestModule):
    def collect(self) -> Iterable[DoctestItem]:
        mode = ImportMode(self.config.getoption("importmode"))
        ignore = os.environ.get("PY_IGNORE_IMPORTMISMATCH", "")

        if mode is not ImportMode.importlib and ignore != "1":
            # we know we will get an import error in this case so ignore it
            os.environ["PY_IGNORE_IMPORTMISMATCH"] = "1"

        try:
            module = self.obj  # import the module
        finally:
            # set ignore variable back to its original value
            os.environ["PY_IGNORE_IMPORTMISMATCH"] = ignore

        test_items = {x.name: x for x in super().collect()}

        # handle tests from Cython's internal __test__ dict generated by
        # the autotestdict directive; we exclude the tests from __test__,
        # though they do give us a little bonus if they exist: we can extract
        # the line number of the test
        lineno_re = re.compile(r'\(line (\d+)\)')
        test_dict = module.__name__ + '.__test__'

        for test_name in list(test_items):
            if not test_name.startswith(test_dict + '.'):
                continue

            match = lineno_re.search(test_name)
            lineno = int(match.group(1)) if match else None

            # If somehow the equivalent test does not already exist, we
            # keep the __test__ test (maybe it is something else not
            # generated by autotestdict)
            equiv_test_name = test_name.split()[0].replace(test_dict, module.__name__)

            if (equiv_test_name not in test_items or not test_items[equiv_test_name].dtest.examples):
                # for some reason the equivalent test was not found (e.g.
                # the module was compiled with docstrings stripped) so keep
                # the __test__ test but hide the fact that it came from the
                # __test__ dict
                test_items[test_name].name = equiv_test_name
                # set lineno on the __test__ test as well, since normally
                # it is not set by doctest
                test_items[test_name].dtest.lineno = lineno
                continue

            # Delete the __test__ test, but try to update the lineno of the
            # equivalent test
            del test_items[test_name]
            test_items[equiv_test_name].dtest.lineno = lineno

        for test in sorted(test_items.values(), key=lambda x: x.name):
            yield test
